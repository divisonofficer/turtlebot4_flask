// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.174.0
//   protoc               v3.12.4
// source: capture.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { LidarPosition, Pose3D } from "./slam";

export const protobufPackage = "";

export interface CaptureAppCapture {
  spaceId: number;
  captureId: number;
  scenes: CaptureAppScene[];
}

export interface CaptureAppScene {
  spaceId: number;
  captureId: number;
  sceneId: number;
  timestamp: number;
  robotPose: Pose3D | undefined;
  images: string[];
  lidarPosition: LidarPosition | undefined;
}

export interface CaptureAppSpace {
  spaceId: number;
  captures: CaptureAppCapture[];
  mapName: string;
  spaceName: string;
  createTime: number;
  updateTime: number;
  useSlam: boolean;
}

export interface CaptureTaskProgress {
  spaceId: number;
  captureId: number;
  sceneId: number;
  progress: number;
  images: string[];
  message: string;
  uid: string;
  action: CaptureTaskProgress_Action;
}

export enum CaptureTaskProgress_Action {
  INIT = 0,
  ACTIVE = 1,
  DONE = 2,
  DEBUG = 3,
  ERROR = 4,
  UNRECOGNIZED = -1,
}

export function captureTaskProgress_ActionFromJSON(object: any): CaptureTaskProgress_Action {
  switch (object) {
    case 0:
    case "INIT":
      return CaptureTaskProgress_Action.INIT;
    case 1:
    case "ACTIVE":
      return CaptureTaskProgress_Action.ACTIVE;
    case 2:
    case "DONE":
      return CaptureTaskProgress_Action.DONE;
    case 3:
    case "DEBUG":
      return CaptureTaskProgress_Action.DEBUG;
    case 4:
    case "ERROR":
      return CaptureTaskProgress_Action.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CaptureTaskProgress_Action.UNRECOGNIZED;
  }
}

export function captureTaskProgress_ActionToJSON(object: CaptureTaskProgress_Action): string {
  switch (object) {
    case CaptureTaskProgress_Action.INIT:
      return "INIT";
    case CaptureTaskProgress_Action.ACTIVE:
      return "ACTIVE";
    case CaptureTaskProgress_Action.DONE:
      return "DONE";
    case CaptureTaskProgress_Action.DEBUG:
      return "DEBUG";
    case CaptureTaskProgress_Action.ERROR:
      return "ERROR";
    case CaptureTaskProgress_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CaptureMessageDef {
  topic: string;
  format: string;
  rosMsgType: CaptureMessageDef_RosMsgType;
}

export enum CaptureMessageDef_RosMsgType {
  Image = 0,
  LaserScan = 1,
  PoseWithCovarianceStamped = 2,
  CompressedImage = 3,
  UNRECOGNIZED = -1,
}

export function captureMessageDef_RosMsgTypeFromJSON(object: any): CaptureMessageDef_RosMsgType {
  switch (object) {
    case 0:
    case "Image":
      return CaptureMessageDef_RosMsgType.Image;
    case 1:
    case "LaserScan":
      return CaptureMessageDef_RosMsgType.LaserScan;
    case 2:
    case "PoseWithCovarianceStamped":
      return CaptureMessageDef_RosMsgType.PoseWithCovarianceStamped;
    case 3:
    case "CompressedImage":
      return CaptureMessageDef_RosMsgType.CompressedImage;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CaptureMessageDef_RosMsgType.UNRECOGNIZED;
  }
}

export function captureMessageDef_RosMsgTypeToJSON(object: CaptureMessageDef_RosMsgType): string {
  switch (object) {
    case CaptureMessageDef_RosMsgType.Image:
      return "Image";
    case CaptureMessageDef_RosMsgType.LaserScan:
      return "LaserScan";
    case CaptureMessageDef_RosMsgType.PoseWithCovarianceStamped:
      return "PoseWithCovarianceStamped";
    case CaptureMessageDef_RosMsgType.CompressedImage:
      return "CompressedImage";
    case CaptureMessageDef_RosMsgType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CaptureMessageDefGroup {
  name: string;
  enabled: boolean;
  messages: CaptureMessageDef[];
}

function createBaseCaptureAppCapture(): CaptureAppCapture {
  return { spaceId: 0, captureId: 0, scenes: [] };
}

export const CaptureAppCapture = {
  encode(message: CaptureAppCapture, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spaceId !== 0) {
      writer.uint32(8).int32(message.spaceId);
    }
    if (message.captureId !== 0) {
      writer.uint32(16).int32(message.captureId);
    }
    for (const v of message.scenes) {
      CaptureAppScene.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CaptureAppCapture {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureAppCapture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spaceId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.captureId = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.scenes.push(CaptureAppScene.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureAppCapture {
    return {
      spaceId: isSet(object.spaceId) ? globalThis.Number(object.spaceId) : 0,
      captureId: isSet(object.captureId) ? globalThis.Number(object.captureId) : 0,
      scenes: globalThis.Array.isArray(object?.scenes)
        ? object.scenes.map((e: any) => CaptureAppScene.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CaptureAppCapture): unknown {
    const obj: any = {};
    if (message.spaceId !== 0) {
      obj.spaceId = Math.round(message.spaceId);
    }
    if (message.captureId !== 0) {
      obj.captureId = Math.round(message.captureId);
    }
    if (message.scenes?.length) {
      obj.scenes = message.scenes.map((e) => CaptureAppScene.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaptureAppCapture>, I>>(base?: I): CaptureAppCapture {
    return CaptureAppCapture.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaptureAppCapture>, I>>(object: I): CaptureAppCapture {
    const message = createBaseCaptureAppCapture();
    message.spaceId = object.spaceId ?? 0;
    message.captureId = object.captureId ?? 0;
    message.scenes = object.scenes?.map((e) => CaptureAppScene.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCaptureAppScene(): CaptureAppScene {
  return {
    spaceId: 0,
    captureId: 0,
    sceneId: 0,
    timestamp: 0,
    robotPose: undefined,
    images: [],
    lidarPosition: undefined,
  };
}

export const CaptureAppScene = {
  encode(message: CaptureAppScene, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spaceId !== 0) {
      writer.uint32(8).int32(message.spaceId);
    }
    if (message.captureId !== 0) {
      writer.uint32(16).int32(message.captureId);
    }
    if (message.sceneId !== 0) {
      writer.uint32(24).int32(message.sceneId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).int32(message.timestamp);
    }
    if (message.robotPose !== undefined) {
      Pose3D.encode(message.robotPose, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.images) {
      writer.uint32(50).string(v!);
    }
    if (message.lidarPosition !== undefined) {
      LidarPosition.encode(message.lidarPosition, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CaptureAppScene {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureAppScene();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spaceId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.captureId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sceneId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestamp = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.robotPose = Pose3D.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.images.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lidarPosition = LidarPosition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureAppScene {
    return {
      spaceId: isSet(object.spaceId) ? globalThis.Number(object.spaceId) : 0,
      captureId: isSet(object.captureId) ? globalThis.Number(object.captureId) : 0,
      sceneId: isSet(object.sceneId) ? globalThis.Number(object.sceneId) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      robotPose: isSet(object.robotPose) ? Pose3D.fromJSON(object.robotPose) : undefined,
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => globalThis.String(e)) : [],
      lidarPosition: isSet(object.lidarPosition) ? LidarPosition.fromJSON(object.lidarPosition) : undefined,
    };
  },

  toJSON(message: CaptureAppScene): unknown {
    const obj: any = {};
    if (message.spaceId !== 0) {
      obj.spaceId = Math.round(message.spaceId);
    }
    if (message.captureId !== 0) {
      obj.captureId = Math.round(message.captureId);
    }
    if (message.sceneId !== 0) {
      obj.sceneId = Math.round(message.sceneId);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.robotPose !== undefined) {
      obj.robotPose = Pose3D.toJSON(message.robotPose);
    }
    if (message.images?.length) {
      obj.images = message.images;
    }
    if (message.lidarPosition !== undefined) {
      obj.lidarPosition = LidarPosition.toJSON(message.lidarPosition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaptureAppScene>, I>>(base?: I): CaptureAppScene {
    return CaptureAppScene.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaptureAppScene>, I>>(object: I): CaptureAppScene {
    const message = createBaseCaptureAppScene();
    message.spaceId = object.spaceId ?? 0;
    message.captureId = object.captureId ?? 0;
    message.sceneId = object.sceneId ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.robotPose = (object.robotPose !== undefined && object.robotPose !== null)
      ? Pose3D.fromPartial(object.robotPose)
      : undefined;
    message.images = object.images?.map((e) => e) || [];
    message.lidarPosition = (object.lidarPosition !== undefined && object.lidarPosition !== null)
      ? LidarPosition.fromPartial(object.lidarPosition)
      : undefined;
    return message;
  },
};

function createBaseCaptureAppSpace(): CaptureAppSpace {
  return { spaceId: 0, captures: [], mapName: "", spaceName: "", createTime: 0, updateTime: 0, useSlam: false };
}

export const CaptureAppSpace = {
  encode(message: CaptureAppSpace, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spaceId !== 0) {
      writer.uint32(8).int32(message.spaceId);
    }
    for (const v of message.captures) {
      CaptureAppCapture.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.mapName !== "") {
      writer.uint32(26).string(message.mapName);
    }
    if (message.spaceName !== "") {
      writer.uint32(34).string(message.spaceName);
    }
    if (message.createTime !== 0) {
      writer.uint32(41).double(message.createTime);
    }
    if (message.updateTime !== 0) {
      writer.uint32(49).double(message.updateTime);
    }
    if (message.useSlam !== false) {
      writer.uint32(56).bool(message.useSlam);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CaptureAppSpace {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureAppSpace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spaceId = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.captures.push(CaptureAppCapture.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mapName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.spaceName = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.createTime = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.updateTime = reader.double();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.useSlam = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureAppSpace {
    return {
      spaceId: isSet(object.spaceId) ? globalThis.Number(object.spaceId) : 0,
      captures: globalThis.Array.isArray(object?.captures)
        ? object.captures.map((e: any) => CaptureAppCapture.fromJSON(e))
        : [],
      mapName: isSet(object.mapName) ? globalThis.String(object.mapName) : "",
      spaceName: isSet(object.spaceName) ? globalThis.String(object.spaceName) : "",
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      updateTime: isSet(object.updateTime) ? globalThis.Number(object.updateTime) : 0,
      useSlam: isSet(object.useSlam) ? globalThis.Boolean(object.useSlam) : false,
    };
  },

  toJSON(message: CaptureAppSpace): unknown {
    const obj: any = {};
    if (message.spaceId !== 0) {
      obj.spaceId = Math.round(message.spaceId);
    }
    if (message.captures?.length) {
      obj.captures = message.captures.map((e) => CaptureAppCapture.toJSON(e));
    }
    if (message.mapName !== "") {
      obj.mapName = message.mapName;
    }
    if (message.spaceName !== "") {
      obj.spaceName = message.spaceName;
    }
    if (message.createTime !== 0) {
      obj.createTime = message.createTime;
    }
    if (message.updateTime !== 0) {
      obj.updateTime = message.updateTime;
    }
    if (message.useSlam !== false) {
      obj.useSlam = message.useSlam;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaptureAppSpace>, I>>(base?: I): CaptureAppSpace {
    return CaptureAppSpace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaptureAppSpace>, I>>(object: I): CaptureAppSpace {
    const message = createBaseCaptureAppSpace();
    message.spaceId = object.spaceId ?? 0;
    message.captures = object.captures?.map((e) => CaptureAppCapture.fromPartial(e)) || [];
    message.mapName = object.mapName ?? "";
    message.spaceName = object.spaceName ?? "";
    message.createTime = object.createTime ?? 0;
    message.updateTime = object.updateTime ?? 0;
    message.useSlam = object.useSlam ?? false;
    return message;
  },
};

function createBaseCaptureTaskProgress(): CaptureTaskProgress {
  return { spaceId: 0, captureId: 0, sceneId: 0, progress: 0, images: [], message: "", uid: "", action: 0 };
}

export const CaptureTaskProgress = {
  encode(message: CaptureTaskProgress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.spaceId !== 0) {
      writer.uint32(8).int32(message.spaceId);
    }
    if (message.captureId !== 0) {
      writer.uint32(16).int32(message.captureId);
    }
    if (message.sceneId !== 0) {
      writer.uint32(24).int32(message.sceneId);
    }
    if (message.progress !== 0) {
      writer.uint32(32).int32(message.progress);
    }
    for (const v of message.images) {
      writer.uint32(42).string(v!);
    }
    if (message.message !== "") {
      writer.uint32(50).string(message.message);
    }
    if (message.uid !== "") {
      writer.uint32(58).string(message.uid);
    }
    if (message.action !== 0) {
      writer.uint32(64).int32(message.action);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CaptureTaskProgress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureTaskProgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.spaceId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.captureId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sceneId = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.progress = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.images.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.message = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureTaskProgress {
    return {
      spaceId: isSet(object.spaceId) ? globalThis.Number(object.spaceId) : 0,
      captureId: isSet(object.captureId) ? globalThis.Number(object.captureId) : 0,
      sceneId: isSet(object.sceneId) ? globalThis.Number(object.sceneId) : 0,
      progress: isSet(object.progress) ? globalThis.Number(object.progress) : 0,
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => globalThis.String(e)) : [],
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      action: isSet(object.action) ? captureTaskProgress_ActionFromJSON(object.action) : 0,
    };
  },

  toJSON(message: CaptureTaskProgress): unknown {
    const obj: any = {};
    if (message.spaceId !== 0) {
      obj.spaceId = Math.round(message.spaceId);
    }
    if (message.captureId !== 0) {
      obj.captureId = Math.round(message.captureId);
    }
    if (message.sceneId !== 0) {
      obj.sceneId = Math.round(message.sceneId);
    }
    if (message.progress !== 0) {
      obj.progress = Math.round(message.progress);
    }
    if (message.images?.length) {
      obj.images = message.images;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.action !== 0) {
      obj.action = captureTaskProgress_ActionToJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaptureTaskProgress>, I>>(base?: I): CaptureTaskProgress {
    return CaptureTaskProgress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaptureTaskProgress>, I>>(object: I): CaptureTaskProgress {
    const message = createBaseCaptureTaskProgress();
    message.spaceId = object.spaceId ?? 0;
    message.captureId = object.captureId ?? 0;
    message.sceneId = object.sceneId ?? 0;
    message.progress = object.progress ?? 0;
    message.images = object.images?.map((e) => e) || [];
    message.message = object.message ?? "";
    message.uid = object.uid ?? "";
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseCaptureMessageDef(): CaptureMessageDef {
  return { topic: "", format: "", rosMsgType: 0 };
}

export const CaptureMessageDef = {
  encode(message: CaptureMessageDef, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.rosMsgType !== 0) {
      writer.uint32(24).int32(message.rosMsgType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CaptureMessageDef {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureMessageDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rosMsgType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureMessageDef {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      rosMsgType: isSet(object.rosMsgType) ? captureMessageDef_RosMsgTypeFromJSON(object.rosMsgType) : 0,
    };
  },

  toJSON(message: CaptureMessageDef): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.rosMsgType !== 0) {
      obj.rosMsgType = captureMessageDef_RosMsgTypeToJSON(message.rosMsgType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaptureMessageDef>, I>>(base?: I): CaptureMessageDef {
    return CaptureMessageDef.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaptureMessageDef>, I>>(object: I): CaptureMessageDef {
    const message = createBaseCaptureMessageDef();
    message.topic = object.topic ?? "";
    message.format = object.format ?? "";
    message.rosMsgType = object.rosMsgType ?? 0;
    return message;
  },
};

function createBaseCaptureMessageDefGroup(): CaptureMessageDefGroup {
  return { name: "", enabled: false, messages: [] };
}

export const CaptureMessageDefGroup = {
  encode(message: CaptureMessageDefGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    for (const v of message.messages) {
      CaptureMessageDef.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CaptureMessageDefGroup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaptureMessageDefGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messages.push(CaptureMessageDef.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaptureMessageDefGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => CaptureMessageDef.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CaptureMessageDefGroup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => CaptureMessageDef.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaptureMessageDefGroup>, I>>(base?: I): CaptureMessageDefGroup {
    return CaptureMessageDefGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaptureMessageDefGroup>, I>>(object: I): CaptureMessageDefGroup {
    const message = createBaseCaptureMessageDefGroup();
    message.name = object.name ?? "";
    message.enabled = object.enabled ?? false;
    message.messages = object.messages?.map((e) => CaptureMessageDef.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
