// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.174.0
//   protoc               v3.12.4
// source: slam.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export interface RobotEuilerOrientation {
  roll: number;
  pitch: number;
  yaw: number;
}

export interface RobotQuaternionOrientation {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface LidarPosition {
  angleMin: number;
  angleMax: number;
  angleIncrement: number;
  ranges: number[];
  rangeMax: number;
}

export interface SlamState {
  status: SlamState_Status;
  message: string;
  robotPose: Pose3D | undefined;
  mapOrigin: Point3D | undefined;
  mapSize: MapInfo | undefined;
  markers: MapMarker[];
  slamMetadata: SlamMetaData | undefined;
}

export enum SlamState_Status {
  SUCCESS = 0,
  ERROR = 1,
  OFFLINE = 2,
  UNRECOGNIZED = -1,
}

export function slamState_StatusFromJSON(object: any): SlamState_Status {
  switch (object) {
    case 0:
    case "SUCCESS":
      return SlamState_Status.SUCCESS;
    case 1:
    case "ERROR":
      return SlamState_Status.ERROR;
    case 2:
    case "OFFLINE":
      return SlamState_Status.OFFLINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SlamState_Status.UNRECOGNIZED;
  }
}

export function slamState_StatusToJSON(object: SlamState_Status): string {
  switch (object) {
    case SlamState_Status.SUCCESS:
      return "SUCCESS";
    case SlamState_Status.ERROR:
      return "ERROR";
    case SlamState_Status.OFFLINE:
      return "OFFLINE";
    case SlamState_Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Pose3D {
  position: Point3D | undefined;
  orientation: RobotQuaternionOrientation | undefined;
  orientationEuler: RobotEuilerOrientation | undefined;
}

export interface Point3D {
  x: number;
  y: number;
  z: number;
}

export interface MapMarker {
  id: number;
  position: Point3D | undefined;
  orientation: RobotEuilerOrientation | undefined;
}

export interface MapInfo {
  width: number;
  height: number;
  resolution: number;
}

export interface SavedMapInfo {
  id: number;
  name: string;
  content: SavedMapMeta | undefined;
  createTime: number;
  createTimeStr: string;
  preview: string;
}

export interface TimeStampInterval {
  interval: number;
  timestamp: number;
  appTime: number;
}

export interface SlamMetaData {
  pose: TimeStampInterval | undefined;
  map: TimeStampInterval | undefined;
  lidar: TimeStampInterval | undefined;
}

export interface SavedMapMeta {
  freeThresh: number;
  image: string;
  mapOrigin: Point3D | undefined;
  mapSize: MapInfo | undefined;
  mode: string;
  resolution: number;
  negate: number;
  occupiedThresh: number;
}

export interface Pose3DArray {
  poses: Pose3D[];
}

export interface Point3DArray {
  points: Point3D[];
}

function createBaseRobotEuilerOrientation(): RobotEuilerOrientation {
  return { roll: 0, pitch: 0, yaw: 0 };
}

export const RobotEuilerOrientation = {
  encode(message: RobotEuilerOrientation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.roll !== 0) {
      writer.uint32(9).double(message.roll);
    }
    if (message.pitch !== 0) {
      writer.uint32(17).double(message.pitch);
    }
    if (message.yaw !== 0) {
      writer.uint32(25).double(message.yaw);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RobotEuilerOrientation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRobotEuilerOrientation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.roll = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.pitch = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.yaw = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RobotEuilerOrientation {
    return {
      roll: isSet(object.roll) ? globalThis.Number(object.roll) : 0,
      pitch: isSet(object.pitch) ? globalThis.Number(object.pitch) : 0,
      yaw: isSet(object.yaw) ? globalThis.Number(object.yaw) : 0,
    };
  },

  toJSON(message: RobotEuilerOrientation): unknown {
    const obj: any = {};
    if (message.roll !== 0) {
      obj.roll = message.roll;
    }
    if (message.pitch !== 0) {
      obj.pitch = message.pitch;
    }
    if (message.yaw !== 0) {
      obj.yaw = message.yaw;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RobotEuilerOrientation>, I>>(base?: I): RobotEuilerOrientation {
    return RobotEuilerOrientation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RobotEuilerOrientation>, I>>(object: I): RobotEuilerOrientation {
    const message = createBaseRobotEuilerOrientation();
    message.roll = object.roll ?? 0;
    message.pitch = object.pitch ?? 0;
    message.yaw = object.yaw ?? 0;
    return message;
  },
};

function createBaseRobotQuaternionOrientation(): RobotQuaternionOrientation {
  return { x: 0, y: 0, z: 0, w: 0 };
}

export const RobotQuaternionOrientation = {
  encode(message: RobotQuaternionOrientation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(25).double(message.z);
    }
    if (message.w !== 0) {
      writer.uint32(33).double(message.w);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RobotQuaternionOrientation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRobotQuaternionOrientation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.z = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.w = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RobotQuaternionOrientation {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      w: isSet(object.w) ? globalThis.Number(object.w) : 0,
    };
  },

  toJSON(message: RobotQuaternionOrientation): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    if (message.w !== 0) {
      obj.w = message.w;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RobotQuaternionOrientation>, I>>(base?: I): RobotQuaternionOrientation {
    return RobotQuaternionOrientation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RobotQuaternionOrientation>, I>>(object: I): RobotQuaternionOrientation {
    const message = createBaseRobotQuaternionOrientation();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.w = object.w ?? 0;
    return message;
  },
};

function createBaseLidarPosition(): LidarPosition {
  return { angleMin: 0, angleMax: 0, angleIncrement: 0, ranges: [], rangeMax: 0 };
}

export const LidarPosition = {
  encode(message: LidarPosition, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.angleMin !== 0) {
      writer.uint32(9).double(message.angleMin);
    }
    if (message.angleMax !== 0) {
      writer.uint32(17).double(message.angleMax);
    }
    if (message.angleIncrement !== 0) {
      writer.uint32(25).double(message.angleIncrement);
    }
    writer.uint32(34).fork();
    for (const v of message.ranges) {
      writer.double(v);
    }
    writer.ldelim();
    if (message.rangeMax !== 0) {
      writer.uint32(41).double(message.rangeMax);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LidarPosition {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLidarPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.angleMin = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.angleMax = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.angleIncrement = reader.double();
          continue;
        case 4:
          if (tag === 33) {
            message.ranges.push(reader.double());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ranges.push(reader.double());
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.rangeMax = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LidarPosition {
    return {
      angleMin: isSet(object.angleMin) ? globalThis.Number(object.angleMin) : 0,
      angleMax: isSet(object.angleMax) ? globalThis.Number(object.angleMax) : 0,
      angleIncrement: isSet(object.angleIncrement) ? globalThis.Number(object.angleIncrement) : 0,
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => globalThis.Number(e)) : [],
      rangeMax: isSet(object.rangeMax) ? globalThis.Number(object.rangeMax) : 0,
    };
  },

  toJSON(message: LidarPosition): unknown {
    const obj: any = {};
    if (message.angleMin !== 0) {
      obj.angleMin = message.angleMin;
    }
    if (message.angleMax !== 0) {
      obj.angleMax = message.angleMax;
    }
    if (message.angleIncrement !== 0) {
      obj.angleIncrement = message.angleIncrement;
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges;
    }
    if (message.rangeMax !== 0) {
      obj.rangeMax = message.rangeMax;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LidarPosition>, I>>(base?: I): LidarPosition {
    return LidarPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LidarPosition>, I>>(object: I): LidarPosition {
    const message = createBaseLidarPosition();
    message.angleMin = object.angleMin ?? 0;
    message.angleMax = object.angleMax ?? 0;
    message.angleIncrement = object.angleIncrement ?? 0;
    message.ranges = object.ranges?.map((e) => e) || [];
    message.rangeMax = object.rangeMax ?? 0;
    return message;
  },
};

function createBaseSlamState(): SlamState {
  return {
    status: 0,
    message: "",
    robotPose: undefined,
    mapOrigin: undefined,
    mapSize: undefined,
    markers: [],
    slamMetadata: undefined,
  };
}

export const SlamState = {
  encode(message: SlamState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.robotPose !== undefined) {
      Pose3D.encode(message.robotPose, writer.uint32(26).fork()).ldelim();
    }
    if (message.mapOrigin !== undefined) {
      Point3D.encode(message.mapOrigin, writer.uint32(34).fork()).ldelim();
    }
    if (message.mapSize !== undefined) {
      MapInfo.encode(message.mapSize, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.markers) {
      MapMarker.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.slamMetadata !== undefined) {
      SlamMetaData.encode(message.slamMetadata, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SlamState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlamState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.robotPose = Pose3D.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mapOrigin = Point3D.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mapSize = MapInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.markers.push(MapMarker.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.slamMetadata = SlamMetaData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlamState {
    return {
      status: isSet(object.status) ? slamState_StatusFromJSON(object.status) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      robotPose: isSet(object.robotPose) ? Pose3D.fromJSON(object.robotPose) : undefined,
      mapOrigin: isSet(object.mapOrigin) ? Point3D.fromJSON(object.mapOrigin) : undefined,
      mapSize: isSet(object.mapSize) ? MapInfo.fromJSON(object.mapSize) : undefined,
      markers: globalThis.Array.isArray(object?.markers) ? object.markers.map((e: any) => MapMarker.fromJSON(e)) : [],
      slamMetadata: isSet(object.slamMetadata) ? SlamMetaData.fromJSON(object.slamMetadata) : undefined,
    };
  },

  toJSON(message: SlamState): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = slamState_StatusToJSON(message.status);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.robotPose !== undefined) {
      obj.robotPose = Pose3D.toJSON(message.robotPose);
    }
    if (message.mapOrigin !== undefined) {
      obj.mapOrigin = Point3D.toJSON(message.mapOrigin);
    }
    if (message.mapSize !== undefined) {
      obj.mapSize = MapInfo.toJSON(message.mapSize);
    }
    if (message.markers?.length) {
      obj.markers = message.markers.map((e) => MapMarker.toJSON(e));
    }
    if (message.slamMetadata !== undefined) {
      obj.slamMetadata = SlamMetaData.toJSON(message.slamMetadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlamState>, I>>(base?: I): SlamState {
    return SlamState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlamState>, I>>(object: I): SlamState {
    const message = createBaseSlamState();
    message.status = object.status ?? 0;
    message.message = object.message ?? "";
    message.robotPose = (object.robotPose !== undefined && object.robotPose !== null)
      ? Pose3D.fromPartial(object.robotPose)
      : undefined;
    message.mapOrigin = (object.mapOrigin !== undefined && object.mapOrigin !== null)
      ? Point3D.fromPartial(object.mapOrigin)
      : undefined;
    message.mapSize = (object.mapSize !== undefined && object.mapSize !== null)
      ? MapInfo.fromPartial(object.mapSize)
      : undefined;
    message.markers = object.markers?.map((e) => MapMarker.fromPartial(e)) || [];
    message.slamMetadata = (object.slamMetadata !== undefined && object.slamMetadata !== null)
      ? SlamMetaData.fromPartial(object.slamMetadata)
      : undefined;
    return message;
  },
};

function createBasePose3D(): Pose3D {
  return { position: undefined, orientation: undefined, orientationEuler: undefined };
}

export const Pose3D = {
  encode(message: Pose3D, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      Point3D.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.orientation !== undefined) {
      RobotQuaternionOrientation.encode(message.orientation, writer.uint32(18).fork()).ldelim();
    }
    if (message.orientationEuler !== undefined) {
      RobotEuilerOrientation.encode(message.orientationEuler, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pose3D {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePose3D();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = Point3D.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orientation = RobotQuaternionOrientation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orientationEuler = RobotEuilerOrientation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pose3D {
    return {
      position: isSet(object.position) ? Point3D.fromJSON(object.position) : undefined,
      orientation: isSet(object.orientation) ? RobotQuaternionOrientation.fromJSON(object.orientation) : undefined,
      orientationEuler: isSet(object.orientationEuler)
        ? RobotEuilerOrientation.fromJSON(object.orientationEuler)
        : undefined,
    };
  },

  toJSON(message: Pose3D): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Point3D.toJSON(message.position);
    }
    if (message.orientation !== undefined) {
      obj.orientation = RobotQuaternionOrientation.toJSON(message.orientation);
    }
    if (message.orientationEuler !== undefined) {
      obj.orientationEuler = RobotEuilerOrientation.toJSON(message.orientationEuler);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pose3D>, I>>(base?: I): Pose3D {
    return Pose3D.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pose3D>, I>>(object: I): Pose3D {
    const message = createBasePose3D();
    message.position = (object.position !== undefined && object.position !== null)
      ? Point3D.fromPartial(object.position)
      : undefined;
    message.orientation = (object.orientation !== undefined && object.orientation !== null)
      ? RobotQuaternionOrientation.fromPartial(object.orientation)
      : undefined;
    message.orientationEuler = (object.orientationEuler !== undefined && object.orientationEuler !== null)
      ? RobotEuilerOrientation.fromPartial(object.orientationEuler)
      : undefined;
    return message;
  },
};

function createBasePoint3D(): Point3D {
  return { x: 0, y: 0, z: 0 };
}

export const Point3D = {
  encode(message: Point3D, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    if (message.z !== 0) {
      writer.uint32(25).double(message.z);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Point3D {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint3D();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.z = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point3D {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
    };
  },

  toJSON(message: Point3D): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== 0) {
      obj.z = message.z;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point3D>, I>>(base?: I): Point3D {
    return Point3D.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point3D>, I>>(object: I): Point3D {
    const message = createBasePoint3D();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    return message;
  },
};

function createBaseMapMarker(): MapMarker {
  return { id: 0, position: undefined, orientation: undefined };
}

export const MapMarker = {
  encode(message: MapMarker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.position !== undefined) {
      Point3D.encode(message.position, writer.uint32(18).fork()).ldelim();
    }
    if (message.orientation !== undefined) {
      RobotEuilerOrientation.encode(message.orientation, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapMarker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapMarker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.position = Point3D.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orientation = RobotEuilerOrientation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapMarker {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      position: isSet(object.position) ? Point3D.fromJSON(object.position) : undefined,
      orientation: isSet(object.orientation) ? RobotEuilerOrientation.fromJSON(object.orientation) : undefined,
    };
  },

  toJSON(message: MapMarker): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.position !== undefined) {
      obj.position = Point3D.toJSON(message.position);
    }
    if (message.orientation !== undefined) {
      obj.orientation = RobotEuilerOrientation.toJSON(message.orientation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapMarker>, I>>(base?: I): MapMarker {
    return MapMarker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapMarker>, I>>(object: I): MapMarker {
    const message = createBaseMapMarker();
    message.id = object.id ?? 0;
    message.position = (object.position !== undefined && object.position !== null)
      ? Point3D.fromPartial(object.position)
      : undefined;
    message.orientation = (object.orientation !== undefined && object.orientation !== null)
      ? RobotEuilerOrientation.fromPartial(object.orientation)
      : undefined;
    return message;
  },
};

function createBaseMapInfo(): MapInfo {
  return { width: 0, height: 0, resolution: 0 };
}

export const MapInfo = {
  encode(message: MapInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.width !== 0) {
      writer.uint32(8).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).int32(message.height);
    }
    if (message.resolution !== 0) {
      writer.uint32(25).double(message.resolution);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MapInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.height = reader.int32();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.resolution = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapInfo {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      resolution: isSet(object.resolution) ? globalThis.Number(object.resolution) : 0,
    };
  },

  toJSON(message: MapInfo): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.resolution !== 0) {
      obj.resolution = message.resolution;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapInfo>, I>>(base?: I): MapInfo {
    return MapInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapInfo>, I>>(object: I): MapInfo {
    const message = createBaseMapInfo();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.resolution = object.resolution ?? 0;
    return message;
  },
};

function createBaseSavedMapInfo(): SavedMapInfo {
  return { id: 0, name: "", content: undefined, createTime: 0, createTimeStr: "", preview: "" };
}

export const SavedMapInfo = {
  encode(message: SavedMapInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.content !== undefined) {
      SavedMapMeta.encode(message.content, writer.uint32(26).fork()).ldelim();
    }
    if (message.createTime !== 0) {
      writer.uint32(37).float(message.createTime);
    }
    if (message.createTimeStr !== "") {
      writer.uint32(42).string(message.createTimeStr);
    }
    if (message.preview !== "") {
      writer.uint32(50).string(message.preview);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SavedMapInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSavedMapInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = SavedMapMeta.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.createTime = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTimeStr = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.preview = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SavedMapInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      content: isSet(object.content) ? SavedMapMeta.fromJSON(object.content) : undefined,
      createTime: isSet(object.createTime) ? globalThis.Number(object.createTime) : 0,
      createTimeStr: isSet(object.createTimeStr) ? globalThis.String(object.createTimeStr) : "",
      preview: isSet(object.preview) ? globalThis.String(object.preview) : "",
    };
  },

  toJSON(message: SavedMapInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.content !== undefined) {
      obj.content = SavedMapMeta.toJSON(message.content);
    }
    if (message.createTime !== 0) {
      obj.createTime = message.createTime;
    }
    if (message.createTimeStr !== "") {
      obj.createTimeStr = message.createTimeStr;
    }
    if (message.preview !== "") {
      obj.preview = message.preview;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SavedMapInfo>, I>>(base?: I): SavedMapInfo {
    return SavedMapInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SavedMapInfo>, I>>(object: I): SavedMapInfo {
    const message = createBaseSavedMapInfo();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.content = (object.content !== undefined && object.content !== null)
      ? SavedMapMeta.fromPartial(object.content)
      : undefined;
    message.createTime = object.createTime ?? 0;
    message.createTimeStr = object.createTimeStr ?? "";
    message.preview = object.preview ?? "";
    return message;
  },
};

function createBaseTimeStampInterval(): TimeStampInterval {
  return { interval: 0, timestamp: 0, appTime: 0 };
}

export const TimeStampInterval = {
  encode(message: TimeStampInterval, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.interval !== 0) {
      writer.uint32(9).double(message.interval);
    }
    if (message.timestamp !== 0) {
      writer.uint32(17).double(message.timestamp);
    }
    if (message.appTime !== 0) {
      writer.uint32(25).double(message.appTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TimeStampInterval {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeStampInterval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.interval = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.timestamp = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.appTime = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeStampInterval {
    return {
      interval: isSet(object.interval) ? globalThis.Number(object.interval) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      appTime: isSet(object.appTime) ? globalThis.Number(object.appTime) : 0,
    };
  },

  toJSON(message: TimeStampInterval): unknown {
    const obj: any = {};
    if (message.interval !== 0) {
      obj.interval = message.interval;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = message.timestamp;
    }
    if (message.appTime !== 0) {
      obj.appTime = message.appTime;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeStampInterval>, I>>(base?: I): TimeStampInterval {
    return TimeStampInterval.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeStampInterval>, I>>(object: I): TimeStampInterval {
    const message = createBaseTimeStampInterval();
    message.interval = object.interval ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.appTime = object.appTime ?? 0;
    return message;
  },
};

function createBaseSlamMetaData(): SlamMetaData {
  return { pose: undefined, map: undefined, lidar: undefined };
}

export const SlamMetaData = {
  encode(message: SlamMetaData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pose !== undefined) {
      TimeStampInterval.encode(message.pose, writer.uint32(10).fork()).ldelim();
    }
    if (message.map !== undefined) {
      TimeStampInterval.encode(message.map, writer.uint32(18).fork()).ldelim();
    }
    if (message.lidar !== undefined) {
      TimeStampInterval.encode(message.lidar, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SlamMetaData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlamMetaData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pose = TimeStampInterval.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.map = TimeStampInterval.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lidar = TimeStampInterval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlamMetaData {
    return {
      pose: isSet(object.pose) ? TimeStampInterval.fromJSON(object.pose) : undefined,
      map: isSet(object.map) ? TimeStampInterval.fromJSON(object.map) : undefined,
      lidar: isSet(object.lidar) ? TimeStampInterval.fromJSON(object.lidar) : undefined,
    };
  },

  toJSON(message: SlamMetaData): unknown {
    const obj: any = {};
    if (message.pose !== undefined) {
      obj.pose = TimeStampInterval.toJSON(message.pose);
    }
    if (message.map !== undefined) {
      obj.map = TimeStampInterval.toJSON(message.map);
    }
    if (message.lidar !== undefined) {
      obj.lidar = TimeStampInterval.toJSON(message.lidar);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SlamMetaData>, I>>(base?: I): SlamMetaData {
    return SlamMetaData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SlamMetaData>, I>>(object: I): SlamMetaData {
    const message = createBaseSlamMetaData();
    message.pose = (object.pose !== undefined && object.pose !== null)
      ? TimeStampInterval.fromPartial(object.pose)
      : undefined;
    message.map = (object.map !== undefined && object.map !== null)
      ? TimeStampInterval.fromPartial(object.map)
      : undefined;
    message.lidar = (object.lidar !== undefined && object.lidar !== null)
      ? TimeStampInterval.fromPartial(object.lidar)
      : undefined;
    return message;
  },
};

function createBaseSavedMapMeta(): SavedMapMeta {
  return {
    freeThresh: 0,
    image: "",
    mapOrigin: undefined,
    mapSize: undefined,
    mode: "",
    resolution: 0,
    negate: 0,
    occupiedThresh: 0,
  };
}

export const SavedMapMeta = {
  encode(message: SavedMapMeta, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.freeThresh !== 0) {
      writer.uint32(9).double(message.freeThresh);
    }
    if (message.image !== "") {
      writer.uint32(18).string(message.image);
    }
    if (message.mapOrigin !== undefined) {
      Point3D.encode(message.mapOrigin, writer.uint32(26).fork()).ldelim();
    }
    if (message.mapSize !== undefined) {
      MapInfo.encode(message.mapSize, writer.uint32(34).fork()).ldelim();
    }
    if (message.mode !== "") {
      writer.uint32(42).string(message.mode);
    }
    if (message.resolution !== 0) {
      writer.uint32(49).double(message.resolution);
    }
    if (message.negate !== 0) {
      writer.uint32(56).int32(message.negate);
    }
    if (message.occupiedThresh !== 0) {
      writer.uint32(65).double(message.occupiedThresh);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SavedMapMeta {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSavedMapMeta();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.freeThresh = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.image = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mapOrigin = Point3D.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mapSize = MapInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mode = reader.string();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.resolution = reader.double();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.negate = reader.int32();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.occupiedThresh = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SavedMapMeta {
    return {
      freeThresh: isSet(object.freeThresh) ? globalThis.Number(object.freeThresh) : 0,
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      mapOrigin: isSet(object.mapOrigin) ? Point3D.fromJSON(object.mapOrigin) : undefined,
      mapSize: isSet(object.mapSize) ? MapInfo.fromJSON(object.mapSize) : undefined,
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      resolution: isSet(object.resolution) ? globalThis.Number(object.resolution) : 0,
      negate: isSet(object.negate) ? globalThis.Number(object.negate) : 0,
      occupiedThresh: isSet(object.occupiedThresh) ? globalThis.Number(object.occupiedThresh) : 0,
    };
  },

  toJSON(message: SavedMapMeta): unknown {
    const obj: any = {};
    if (message.freeThresh !== 0) {
      obj.freeThresh = message.freeThresh;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.mapOrigin !== undefined) {
      obj.mapOrigin = Point3D.toJSON(message.mapOrigin);
    }
    if (message.mapSize !== undefined) {
      obj.mapSize = MapInfo.toJSON(message.mapSize);
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.resolution !== 0) {
      obj.resolution = message.resolution;
    }
    if (message.negate !== 0) {
      obj.negate = Math.round(message.negate);
    }
    if (message.occupiedThresh !== 0) {
      obj.occupiedThresh = message.occupiedThresh;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SavedMapMeta>, I>>(base?: I): SavedMapMeta {
    return SavedMapMeta.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SavedMapMeta>, I>>(object: I): SavedMapMeta {
    const message = createBaseSavedMapMeta();
    message.freeThresh = object.freeThresh ?? 0;
    message.image = object.image ?? "";
    message.mapOrigin = (object.mapOrigin !== undefined && object.mapOrigin !== null)
      ? Point3D.fromPartial(object.mapOrigin)
      : undefined;
    message.mapSize = (object.mapSize !== undefined && object.mapSize !== null)
      ? MapInfo.fromPartial(object.mapSize)
      : undefined;
    message.mode = object.mode ?? "";
    message.resolution = object.resolution ?? 0;
    message.negate = object.negate ?? 0;
    message.occupiedThresh = object.occupiedThresh ?? 0;
    return message;
  },
};

function createBasePose3DArray(): Pose3DArray {
  return { poses: [] };
}

export const Pose3DArray = {
  encode(message: Pose3DArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.poses) {
      Pose3D.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Pose3DArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePose3DArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.poses.push(Pose3D.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pose3DArray {
    return { poses: globalThis.Array.isArray(object?.poses) ? object.poses.map((e: any) => Pose3D.fromJSON(e)) : [] };
  },

  toJSON(message: Pose3DArray): unknown {
    const obj: any = {};
    if (message.poses?.length) {
      obj.poses = message.poses.map((e) => Pose3D.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pose3DArray>, I>>(base?: I): Pose3DArray {
    return Pose3DArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pose3DArray>, I>>(object: I): Pose3DArray {
    const message = createBasePose3DArray();
    message.poses = object.poses?.map((e) => Pose3D.fromPartial(e)) || [];
    return message;
  },
};

function createBasePoint3DArray(): Point3DArray {
  return { points: [] };
}

export const Point3DArray = {
  encode(message: Point3DArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.points) {
      Point3D.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Point3DArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint3DArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.points.push(Point3D.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point3DArray {
    return {
      points: globalThis.Array.isArray(object?.points) ? object.points.map((e: any) => Point3D.fromJSON(e)) : [],
    };
  },

  toJSON(message: Point3DArray): unknown {
    const obj: any = {};
    if (message.points?.length) {
      obj.points = message.points.map((e) => Point3D.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Point3DArray>, I>>(base?: I): Point3DArray {
    return Point3DArray.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Point3DArray>, I>>(object: I): Point3DArray {
    const message = createBasePoint3DArray();
    message.points = object.points?.map((e) => Point3D.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
